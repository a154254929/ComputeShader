// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSCulling

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

StructuredBuffer<float3> posAllBuffer;
RWStructuredBuffer<float3> posVisibleBuffer;
RWStructuredBuffer<int> bufferWithArgs;
float offsetValue;
float3 cmrPos;
float3 cmrDir;
float cmrHalfFov;
float4x4 matrix_VP;
Texture2D HZB_Depth;
float useHzb;

[numthreads(16,16,1)]
void CSCulling(uint3 id : SV_DispatchThreadID)
{
	//草的id
	uint index = id.y * 400 + id.x;
	float3 itemPos = posAllBuffer[index];
	float3 itemDir = normalize(itemPos - cmrPos);
	float rot = dot(cmrDir, itemDir);
	//做一些往相机方向的偏移之后转换到齐次裁剪空间
 	float4 clipPos = mul(matrix_VP, float4(itemPos - cmrDir * offsetValue, 1));
	if (max(abs(clipPos.x), abs(clipPos.y)) > clipPos.w + 0.7)return;
 	if (useHzb > 0.5) {
		clipPos.xyz /= clipPos.w;
		clipPos.xy = clipPos.xy * 0.5 + 0.5;
		float scWid = 0.2 / (tan(cmrHalfFov * 3.1415926 / 180) * clipPos.w) * 1024;

		//将一棵草所占的像素转到刚好占4个像素的mipmap下计算
		//uint mips = (uint)clamp(log2(scWid), 0,7);
		uint mips = (uint)clamp(log2(scWid), 0,7);
		uint2 uv = uint2(clipPos.xy * (1024 >> mips));
		float minD = min(
			min(
				HZB_Depth.mips[mips][uv.xy + uint2(0, 0)].r,
				HZB_Depth.mips[mips][uv.xy + uint2(0, 1)].r
			),
			min(
				HZB_Depth.mips[mips][uv.xy + uint2(1, 0)].r,
				HZB_Depth.mips[mips][uv.xy + uint2(1, 1)].r
			)
		);
		if (minD > clipPos.z)return;
	}
	int currentIndex;
	InterlockedAdd(bufferWithArgs[1], 1, currentIndex);
	posVisibleBuffer[currentIndex] = itemPos;
}
